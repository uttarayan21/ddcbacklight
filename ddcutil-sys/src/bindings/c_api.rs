/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[doc = " **ddcutil** Status Code\n\n  Most public **ddcutil** functions return a status code.\n  These status codes have 3 sources:\n  - Linux\n  - ADL (AMD Display Library) (no longer used)\n  - **ddcutil** itself\n\n  These multiple status code sources are consolidated by \"modulating\"\n  the raw values into non-overlapping ranges.\n  - Linux errno values are returned as negative numbers (e.g. -EIO)\n  - ADL values are modulated by 2000 (i.e., 2000 subtracted from negative ADL status codes,\n         or added to positive ADL status codes) (no longer used)\n  - ddcutil errors are always in the -3000 range\n\n  In summary:\n  - 0 always indicates a normal successful status\n  - Positive values (possible with ADL) represent qualified success of some sort (no longer used)\n  - Negative values indicate an error condition."]
pub type DDCA_Status = ::std::os::raw::c_int;
#[doc = "! ddcutil version\n!"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Ddcutil_Version_Spec {
    #[doc = "< Major release number"]
    pub major: u8,
    #[doc = "< Minor release number"]
    pub minor: u8,
    #[doc = "< Micro release number"]
    pub micro: u8,
}
#[test]
fn bindgen_test_layout_DDCA_Ddcutil_Version_Spec() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Ddcutil_Version_Spec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Ddcutil_Version_Spec>(),
        3usize,
        concat!("Size of: ", stringify!(DDCA_Ddcutil_Version_Spec))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Ddcutil_Version_Spec>(),
        1usize,
        concat!("Alignment of ", stringify!(DDCA_Ddcutil_Version_Spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Ddcutil_Version_Spec),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Ddcutil_Version_Spec),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).micro) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Ddcutil_Version_Spec),
            "::",
            stringify!(micro)
        )
    );
}
#[doc = " @deprecated @brief ddcutil was built with support for AMD Display Library connected monitors"]
pub const DDCA_Build_Option_Flags_DDCA_BUILT_WITH_ADL: DDCA_Build_Option_Flags = 1;
#[doc = " @brief ddcutil was built with support for USB connected monitors"]
pub const DDCA_Build_Option_Flags_DDCA_BUILT_WITH_USB: DDCA_Build_Option_Flags = 2;
#[doc = " @brief ddcutil was built with support for failure simulation"]
pub const DDCA_Build_Option_Flags_DDCA_BUILT_WITH_FAILSIM: DDCA_Build_Option_Flags = 4;
#[doc = "! Build option flags, as returned by #ddca_build_options()\n! The enum values are defined as 1,2,4 etc so that they can be or'd."]
pub type DDCA_Build_Option_Flags = ::std::os::raw::c_uint;
#[doc = "! Detailed error report"]
#[repr(C)]
#[derive(Debug)]
pub struct ddca_error_detail {
    #[doc = "< Always \"EDTL\""]
    pub marker: [::std::os::raw::c_char; 4usize],
    #[doc = "< Error code"]
    pub status_code: DDCA_Status,
    #[doc = "< Optional explanation string"]
    pub detail: *mut ::std::os::raw::c_char,
    #[doc = "< Number of sub-errors"]
    pub cause_ct: u16,
    #[doc = "< Variable length array of contributing errors"]
    pub causes: __IncompleteArrayField<*mut ddca_error_detail>,
}
#[test]
fn bindgen_test_layout_ddca_error_detail() {
    const UNINIT: ::std::mem::MaybeUninit<ddca_error_detail> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ddca_error_detail>(),
        24usize,
        concat!("Size of: ", stringify!(ddca_error_detail))
    );
    assert_eq!(
        ::std::mem::align_of::<ddca_error_detail>(),
        8usize,
        concat!("Alignment of ", stringify!(ddca_error_detail))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ddca_error_detail),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ddca_error_detail),
            "::",
            stringify!(status_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ddca_error_detail),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cause_ct) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ddca_error_detail),
            "::",
            stringify!(cause_ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).causes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ddca_error_detail),
            "::",
            stringify!(causes)
        )
    );
}
#[doc = "! Detailed error report"]
pub type DDCA_Error_Detail = ddca_error_detail;
#[doc = "< Maximum write-only operation tries"]
pub const DDCA_Retry_Type_DDCA_WRITE_ONLY_TRIES: DDCA_Retry_Type = 0;
#[doc = "< Maximum read-write operation tries"]
pub const DDCA_Retry_Type_DDCA_WRITE_READ_TRIES: DDCA_Retry_Type = 1;
#[doc = "< Maximum multi-part operation tries"]
pub const DDCA_Retry_Type_DDCA_MULTI_PART_TRIES: DDCA_Retry_Type = 2;
#[doc = "! I2C retry limit types"]
pub type DDCA_Retry_Type = ::std::os::raw::c_uint;
#[doc = "< Brief   output"]
pub const DDCA_Output_Level_DDCA_OL_TERSE: DDCA_Output_Level = 4;
#[doc = "< Normal  output"]
pub const DDCA_Output_Level_DDCA_OL_NORMAL: DDCA_Output_Level = 8;
#[doc = "< Verbose output"]
pub const DDCA_Output_Level_DDCA_OL_VERBOSE: DDCA_Output_Level = 16;
#[doc = "< Very verbose output"]
pub const DDCA_Output_Level_DDCA_OL_VV: DDCA_Output_Level = 32;
#[doc = "! Output Level\n!\n! Values assigned to constants allow them to be or'd in bit flags.\n!\n! Values are ascending in order of verbosity"]
pub type DDCA_Output_Level = ::std::os::raw::c_uint;
#[doc = "< base functions"]
pub const DDCA_Trace_Group_DDCA_TRC_BASE: DDCA_Trace_Group = 128;
#[doc = "< I2C layer"]
pub const DDCA_Trace_Group_DDCA_TRC_I2C: DDCA_Trace_Group = 64;
#[doc = "< @deprecated ADL layer"]
pub const DDCA_Trace_Group_DDCA_TRC_ADL: DDCA_Trace_Group = 32;
#[doc = "< DDC layer"]
pub const DDCA_Trace_Group_DDCA_TRC_DDC: DDCA_Trace_Group = 16;
#[doc = "< USB connected display functions"]
pub const DDCA_Trace_Group_DDCA_TRC_USB: DDCA_Trace_Group = 8;
#[doc = "< ddcutil mainline"]
pub const DDCA_Trace_Group_DDCA_TRC_TOP: DDCA_Trace_Group = 4;
#[doc = "< environment command"]
pub const DDCA_Trace_Group_DDCA_TRC_ENV: DDCA_Trace_Group = 2;
#[doc = "< top level API functions"]
pub const DDCA_Trace_Group_DDCA_TRC_API: DDCA_Trace_Group = 1;
#[doc = "< user-defined, aka dynamic, features"]
pub const DDCA_Trace_Group_DDCA_TRC_UDF: DDCA_Trace_Group = 256;
#[doc = "< VCP layer, feature definitions"]
pub const DDCA_Trace_Group_DDCA_TRC_VCP: DDCA_Trace_Group = 512;
#[doc = "< DDC IO functions"]
pub const DDCA_Trace_Group_DDCA_TRC_DDCIO: DDCA_Trace_Group = 1024;
#[doc = "< low level sleeps"]
pub const DDCA_Trace_Group_DDCA_TRC_SLEEP: DDCA_Trace_Group = 2048;
#[doc = "< successful retries, subset of DDCA_TRC_DDCIO"]
pub const DDCA_Trace_Group_DDCA_TRC_RETRY: DDCA_Trace_Group = 4096;
#[doc = "< all tracing disabled"]
pub const DDCA_Trace_Group_DDCA_TRC_NONE: DDCA_Trace_Group = 0;
#[doc = "< all tracing enabled"]
pub const DDCA_Trace_Group_DDCA_TRC_ALL: DDCA_Trace_Group = 65535;
#[doc = "! Trace Control\n!\n! Used as bitflags to specify multiple trace types"]
pub type DDCA_Trace_Group = ::std::os::raw::c_uint;
pub const DDCA_Trace_Options_DDCA_TRCOPT_TIMESTAMP: DDCA_Trace_Options = 1;
pub const DDCA_Trace_Options_DDCA_TRCOPT_THREAD_ID: DDCA_Trace_Options = 2;
pub const DDCA_Trace_Options_DDCA_TRCOPT_WALLTIME: DDCA_Trace_Options = 4;
pub type DDCA_Trace_Options = ::std::os::raw::c_uint;
#[doc = "< no statistics"]
pub const DDCA_Stats_Type_DDCA_STATS_NONE: DDCA_Stats_Type = 0;
#[doc = "< retry statistics"]
pub const DDCA_Stats_Type_DDCA_STATS_TRIES: DDCA_Stats_Type = 1;
#[doc = "< error statistics"]
pub const DDCA_Stats_Type_DDCA_STATS_ERRORS: DDCA_Stats_Type = 2;
#[doc = "< system calls"]
pub const DDCA_Stats_Type_DDCA_STATS_CALLS: DDCA_Stats_Type = 4;
#[doc = "< total elapsed time"]
pub const DDCA_Stats_Type_DDCA_STATS_ELAPSED: DDCA_Stats_Type = 8;
#[doc = "< indicates all statistics types"]
pub const DDCA_Stats_Type_DDCA_STATS_ALL: DDCA_Stats_Type = 255;
#[doc = "! Used as values to specify a single statistics type, and as\n! bitflags to select statistics types."]
pub type DDCA_Stats_Type = ::std::os::raw::c_uint;
#[doc = "< @brief no options specified"]
pub const DDCA_Capture_Option_Flags_DDCA_CAPTURE_NOOPTS: DDCA_Capture_Option_Flags = 0;
#[doc = "< @brief capture **stderr** as well as **stdout**"]
pub const DDCA_Capture_Option_Flags_DDCA_CAPTURE_STDERR: DDCA_Capture_Option_Flags = 1;
#[doc = "! Capture option flags, used by #ddca_start_capture()\n!\n! The enum values are defined as 1,2,4 etc so that they can be or'd.\n!\n!  @since 0.9.0"]
pub type DDCA_Capture_Option_Flags = ::std::os::raw::c_uint;
#[doc = " Opaque display identifier\n\n A **DDCA_Display_Identifier** holds the criteria for selecting a monitor,\n typically as specified by the user.\n\n It can take several forms:\n - the display number assigned by **dccutil**\n - an I2C bus number\n - an ADL (adapter index, display index) pair (deprecated)\n - a  USB (bus number, device number) pair or USB device number\n - an EDID\n - manufacturer, model, and serial number strings\n\n @ingroup api_display_spec"]
pub type DDCA_Display_Identifier = *mut ::std::os::raw::c_void;
#[doc = " Opaque display reference.\n\n A #DDCA_Display_Ref describes a monitor.  It contains 3 kinds of information:\n - Assigned ddcutil display number\n - The operating system path to the monitor, which is an I2C bus number or\n   a USB device number.\n - Accumulated information about the monitor, such as the EDID or capabilities string.\n\n @remark\n When libddcutil is started, it detects all connected monitors and creates\n a persistent #DDCA_DisplayRef for each.\n @remark\n A #DDCA_Display_Ref can be obtained in 2 ways:\n - From the DDCA_Display_List returned by #ddca_get_display_info_list2()\n - Searching based on #DDCA_Display_Identifier using #ddca_get_display_ref()\n\n @ingroup api_display_spec"]
pub type DDCA_Display_Ref = *mut ::std::os::raw::c_void;
#[doc = " Opaque display handle\n\n A **DDCA_Display_Handle** represents an \"open\" display on which actions can be\n performed. This is required for communicating with a display. It is obtained by\n calling #ddca_open_display2().\n\n For I2C and USB connected displays, an operating system open is performed by\n # ddca_open_display2().  #DDCA_Display_Handle then contains the file handle\n returned by the operating system.\n\n @ingroup api_display_spec"]
pub type DDCA_Display_Handle = *mut ::std::os::raw::c_void;
#[doc = " @deprecated ADL adapter number/display number pair, which identifies a display"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Adlno {
    #[doc = "< adapter number"]
    pub iAdapterIndex: ::std::os::raw::c_int,
    #[doc = "< display number"]
    pub iDisplayIndex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DDCA_Adlno() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Adlno> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Adlno>(),
        8usize,
        concat!("Size of: ", stringify!(DDCA_Adlno))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Adlno>(),
        4usize,
        concat!("Alignment of ", stringify!(DDCA_Adlno))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iAdapterIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Adlno),
            "::",
            stringify!(iAdapterIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iDisplayIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Adlno),
            "::",
            stringify!(iDisplayIndex)
        )
    );
}
#[doc = " MCCS Version in binary form"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_MCCS_Version_Spec {
    #[doc = "< major version number"]
    pub major: u8,
    pub minor: u8,
}
#[test]
fn bindgen_test_layout_DDCA_MCCS_Version_Spec() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_MCCS_Version_Spec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_MCCS_Version_Spec>(),
        2usize,
        concat!("Size of: ", stringify!(DDCA_MCCS_Version_Spec))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_MCCS_Version_Spec>(),
        1usize,
        concat!("Alignment of ", stringify!(DDCA_MCCS_Version_Spec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_MCCS_Version_Spec),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_MCCS_Version_Spec),
            "::",
            stringify!(minor)
        )
    );
}
#[doc = " MCCS VCP Feature Id"]
pub type DDCA_Vcp_Feature_Code = u8;
#[doc = " Bitfield specifying a collection of VCP feature codes\n\n  @remark\n  This struct might be more appropriately named DDCA_Feature_Set, but\n  that results in confusing function names such as ddca_feature_set_set()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Feature_List {
    pub bytes: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_DDCA_Feature_List() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Feature_List> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Feature_List>(),
        32usize,
        concat!("Size of: ", stringify!(DDCA_Feature_List))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Feature_List>(),
        1usize,
        concat!("Alignment of ", stringify!(DDCA_Feature_List))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_List),
            "::",
            stringify!(bytes)
        )
    );
}
#[doc = "< No subset selected"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_UNSET: DDCA_Feature_Subset_Id = 0;
#[doc = "< All features defined in a MCCS spec"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_KNOWN: DDCA_Feature_Subset_Id = 1;
#[doc = "< Color related features"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_COLOR: DDCA_Feature_Subset_Id = 2;
#[doc = "< Features saved and restored by loadvcp/setvcp"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_PROFILE: DDCA_Feature_Subset_Id = 3;
#[doc = "< Feature codes reserved for manufacturer use (0x0e..0xff)"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_MFG: DDCA_Feature_Subset_Id = 4;
#[doc = "< Feature codes specified in capabilities string"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_CAPABILITIES: DDCA_Feature_Subset_Id = 5;
#[doc = "< All feature codes other than known write-only or table"]
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_SCAN: DDCA_Feature_Subset_Id = 6;
pub const DDCA_Feature_Subset_Id_DDCA_SUBSET_CUSTOM: DDCA_Feature_Subset_Id = 7;
#[doc = " Identifiers for publicly useful VCP feature subsets\n\n @remark\n These subset identifiers represent a subset of the much\n larger collection of subset ids used internally."]
pub type DDCA_Feature_Subset_Id = ::std::os::raw::c_uint;
#[doc = "< Use DDC to communicate with a /dev/i2c-n device"]
pub const DDCA_IO_Mode_DDCA_IO_I2C: DDCA_IO_Mode = 0;
#[doc = "< @deprecated Use ADL API"]
pub const DDCA_IO_Mode_DDCA_IO_ADL: DDCA_IO_Mode = 1;
#[doc = "< Use USB reports for a USB connected monitor"]
pub const DDCA_IO_Mode_DDCA_IO_USB: DDCA_IO_Mode = 2;
#[doc = " Indicates how MCCS communication is performed"]
pub type DDCA_IO_Mode = ::std::os::raw::c_uint;
#[doc = " Describes a display's physical access mode and the location identifiers for that mode"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DDCA_IO_Path {
    #[doc = "< physical access mode"]
    pub io_mode: DDCA_IO_Mode,
    pub path: DDCA_IO_Path__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DDCA_IO_Path__bindgen_ty_1 {
    #[doc = "< I2C bus number"]
    pub i2c_busno: ::std::os::raw::c_int,
    #[doc = "< @deprecated ADL iAdapterIndex/iDisplayIndex pair"]
    pub adlno: DDCA_Adlno,
    pub hiddev_devno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_DDCA_IO_Path__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_IO_Path__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_IO_Path__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(DDCA_IO_Path__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_IO_Path__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DDCA_IO_Path__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i2c_busno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_IO_Path__bindgen_ty_1),
            "::",
            stringify!(i2c_busno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adlno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_IO_Path__bindgen_ty_1),
            "::",
            stringify!(adlno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hiddev_devno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_IO_Path__bindgen_ty_1),
            "::",
            stringify!(hiddev_devno)
        )
    );
}
#[test]
fn bindgen_test_layout_DDCA_IO_Path() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_IO_Path> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_IO_Path>(),
        12usize,
        concat!("Size of: ", stringify!(DDCA_IO_Path))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_IO_Path>(),
        4usize,
        concat!("Alignment of ", stringify!(DDCA_IO_Path))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_IO_Path),
            "::",
            stringify!(io_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_IO_Path),
            "::",
            stringify!(path)
        )
    );
}
#[doc = " Describes one monitor detected by ddcutil.\n\n  This struct is copied to the caller and can simply be freed."]
#[repr(C)]
// #[derive(Copy, Clone)]
pub struct DDCA_Display_Info {
    #[doc = "< always \"DDIN\""]
    pub marker: [::std::os::raw::c_char; 4usize],
    #[doc = "< ddcutil assigned display number"]
    pub dispno: ::std::os::raw::c_int,
    #[doc = "< physical access path to display"]
    pub path: DDCA_IO_Path,
    #[doc = "< USB bus number, if USB connection"]
    pub usb_bus: ::std::os::raw::c_int,
    #[doc = "< USB device number, if USB connection"]
    pub usb_device: ::std::os::raw::c_int,
    #[doc = "< 3 character mfg id from EDID"]
    pub mfg_id: [::std::os::raw::c_char; 4usize],
    #[doc = "< model name from EDID, 13 char max"]
    pub model_name: [::std::os::raw::c_char; 14usize],
    #[doc = "< \"serial number\" from EDID, 13 char max"]
    pub sn: [::std::os::raw::c_char; 14usize],
    #[doc = "< model product number"]
    pub product_code: u16,
    #[doc = "< first 128 bytes of EDID"]
    pub edid_bytes: [u8; 128usize],
    #[doc = "< VCP version as pair of numbers"]
    pub vcp_version: DDCA_MCCS_Version_Spec,
    #[doc = "< opaque display reference"]
    pub dref: DDCA_Display_Ref,
}
#[test]
fn bindgen_test_layout_DDCA_Display_Info() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Display_Info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Display_Info>(),
        200usize,
        concat!("Size of: ", stringify!(DDCA_Display_Info))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Display_Info>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Display_Info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(dispno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usb_bus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(usb_bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usb_device) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(usb_device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mfg_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(mfg_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(model_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sn) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(sn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).product_code) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(product_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).edid_bytes) as usize - ptr as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(edid_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcp_version) as usize - ptr as usize },
        190usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(vcp_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dref) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info),
            "::",
            stringify!(dref)
        )
    );
}
#[doc = " Collection of #DDCA_Display_Info"]
#[repr(C)]
pub struct DDCA_Display_Info_List {
    #[doc = "< number of records"]
    pub ct: ::std::os::raw::c_int,
    #[doc = "< array whose size is determined by ct"]
    pub info: __IncompleteArrayField<DDCA_Display_Info>,
}
#[test]
fn bindgen_test_layout_DDCA_Display_Info_List() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Display_Info_List> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Display_Info_List>(),
        8usize,
        concat!("Size of: ", stringify!(DDCA_Display_Info_List))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Display_Info_List>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Display_Info_List))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ct) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info_List),
            "::",
            stringify!(ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Display_Info_List),
            "::",
            stringify!(info)
        )
    );
}
pub type DDCA_Feature_Flags = u16;
#[doc = " One entry in array listing defined simple NC values.\n\n An entry of {0x00,NULL} terminates the list."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Feature_Value_Entry {
    pub value_code: u8,
    pub value_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DDCA_Feature_Value_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Feature_Value_Entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Feature_Value_Entry>(),
        16usize,
        concat!("Size of: ", stringify!(DDCA_Feature_Value_Entry))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Feature_Value_Entry>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Feature_Value_Entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Value_Entry),
            "::",
            stringify!(value_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Value_Entry),
            "::",
            stringify!(value_name)
        )
    );
}
#[doc = " Describes a VCP feature code, tailored for a specific monitor.\n  Feature metadata can vary by VCP version and user defined features"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Feature_Metadata {
    #[doc = "< always \"FMET\""]
    pub marker: [::std::os::raw::c_char; 4usize],
    #[doc = "< VCP feature code"]
    pub feature_code: DDCA_Vcp_Feature_Code,
    #[doc = "< MCCS version"]
    pub vcp_version: DDCA_MCCS_Version_Spec,
    #[doc = "< feature type description"]
    pub feature_flags: DDCA_Feature_Flags,
    #[doc = "< valid when DDCA_SIMPLE_NC set"]
    pub sl_values: *mut DDCA_Feature_Value_Entry,
    pub latest_sl_values: *mut DDCA_Feature_Value_Entry,
    #[doc = "< feature name"]
    pub feature_name: *mut ::std::os::raw::c_char,
    #[doc = "< feature description"]
    pub feature_desc: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DDCA_Feature_Metadata() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Feature_Metadata> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Feature_Metadata>(),
        48usize,
        concat!("Size of: ", stringify!(DDCA_Feature_Metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Feature_Metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Feature_Metadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(feature_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcp_version) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(vcp_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(feature_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sl_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(sl_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latest_sl_values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(latest_sl_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(feature_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_desc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Feature_Metadata),
            "::",
            stringify!(feature_desc)
        )
    );
}
#[doc = " Represents one feature code in the vcp() section of the capabilities string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Cap_Vcp {
    #[doc = "< Always DDCA_CAP_VCP_MARKER"]
    pub marker: [::std::os::raw::c_char; 4usize],
    #[doc = "< VCP feature code"]
    pub feature_code: DDCA_Vcp_Feature_Code,
    #[doc = "< number of values declared"]
    pub value_ct: ::std::os::raw::c_int,
    #[doc = "< array of declared values"]
    pub values: *mut u8,
}
#[test]
fn bindgen_test_layout_DDCA_Cap_Vcp() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Cap_Vcp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Cap_Vcp>(),
        24usize,
        concat!("Size of: ", stringify!(DDCA_Cap_Vcp))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Cap_Vcp>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Cap_Vcp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Cap_Vcp),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feature_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Cap_Vcp),
            "::",
            stringify!(feature_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_ct) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Cap_Vcp),
            "::",
            stringify!(value_ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Cap_Vcp),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " Represents a monitor capabilities string"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Capabilities {
    #[doc = "< always DDCA_CAPABILITIES_MARKER"]
    pub marker: [::std::os::raw::c_char; 4usize],
    #[doc = "< unparsed capabilities string"]
    pub unparsed_string: *mut ::std::os::raw::c_char,
    #[doc = "< parsed mccs_ver() field"]
    pub version_spec: DDCA_MCCS_Version_Spec,
    #[doc = "< number of command codes"]
    pub cmd_ct: ::std::os::raw::c_int,
    #[doc = "< array of command codes"]
    pub cmd_codes: *mut u8,
    #[doc = "< number of features in vcp() field"]
    pub vcp_code_ct: ::std::os::raw::c_int,
    #[doc = "< array of pointers to structs describing each vcp code"]
    pub vcp_codes: *mut DDCA_Cap_Vcp,
    pub msg_ct: ::std::os::raw::c_int,
    pub messages: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DDCA_Capabilities() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Capabilities> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Capabilities>(),
        64usize,
        concat!("Size of: ", stringify!(DDCA_Capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Capabilities>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Capabilities))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(marker)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unparsed_string) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(unparsed_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_spec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(version_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_ct) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(cmd_ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmd_codes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(cmd_codes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcp_code_ct) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(vcp_code_ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcp_codes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(vcp_codes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_ct) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(msg_ct)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messages) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Capabilities),
            "::",
            stringify!(messages)
        )
    );
}
#[doc = "< Continuous (C) or Non-Continuous (NC) value"]
pub const DDCA_Vcp_Value_Type_DDCA_NON_TABLE_VCP_VALUE: DDCA_Vcp_Value_Type = 1;
#[doc = "< Table (T) value"]
pub const DDCA_Vcp_Value_Type_DDCA_TABLE_VCP_VALUE: DDCA_Vcp_Value_Type = 2;
#[doc = " Indicates the physical data type.  At the DDC level, continuous (C) and\n  non-continuous (NC) features are treated identically.  They share the same\n  DDC commands (Get VCP Feature and VCP Feature Reply) and data structure.\n  Table (T) features use DDC commands Table Write and Table Read, which take\n  different data structures."]
pub type DDCA_Vcp_Value_Type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Non_Table_Vcp_Value {
    pub mh: u8,
    pub ml: u8,
    pub sh: u8,
    pub sl: u8,
}
#[test]
fn bindgen_test_layout_DDCA_Non_Table_Vcp_Value() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Non_Table_Vcp_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Non_Table_Vcp_Value>(),
        4usize,
        concat!("Size of: ", stringify!(DDCA_Non_Table_Vcp_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Non_Table_Vcp_Value>(),
        1usize,
        concat!("Alignment of ", stringify!(DDCA_Non_Table_Vcp_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Non_Table_Vcp_Value),
            "::",
            stringify!(mh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Non_Table_Vcp_Value),
            "::",
            stringify!(ml)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sh) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Non_Table_Vcp_Value),
            "::",
            stringify!(sh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sl) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Non_Table_Vcp_Value),
            "::",
            stringify!(sl)
        )
    );
}
#[doc = " Represents a single table VCP value.   Consists of a count, and a pointer to the bytes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Table_Vcp_Value {
    #[doc = "< Number of bytes in value"]
    pub bytect: u16,
    #[doc = "< Bytes of the value"]
    pub bytes: *mut u8,
}
#[test]
fn bindgen_test_layout_DDCA_Table_Vcp_Value() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Table_Vcp_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Table_Vcp_Value>(),
        16usize,
        concat!("Size of: ", stringify!(DDCA_Table_Vcp_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Table_Vcp_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Table_Vcp_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Table_Vcp_Value),
            "::",
            stringify!(bytect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Table_Vcp_Value),
            "::",
            stringify!(bytes)
        )
    );
}
#[doc = " Stores a VCP feature value of any type"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DDCA_Any_Vcp_Value {
    #[doc = "< VCP feature code"]
    pub opcode: DDCA_Vcp_Feature_Code,
    pub value_type: DDCA_Vcp_Value_Type,
    pub val: DDCA_Any_Vcp_Value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DDCA_Any_Vcp_Value__bindgen_ty_1 {
    #[doc = "< table value"]
    pub t: DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< continuous non-continuous, i.e. non-table, value"]
    pub c_nc: DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< pointer to bytes of table value"]
    pub bytes: *mut u8,
    #[doc = "< number of bytes in table value"]
    pub bytect: u16,
}
#[test]
fn bindgen_test_layout_DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(bytect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2 {
    pub mh: u8,
    pub ml: u8,
    pub sh: u8,
    pub sl: u8,
}
#[test]
fn bindgen_test_layout_DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(mh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ml) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ml)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sh) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sl) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sl)
        )
    );
}
#[test]
fn bindgen_test_layout_DDCA_Any_Vcp_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Any_Vcp_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Any_Vcp_Value__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Any_Vcp_Value__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).c_nc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value__bindgen_ty_1),
            "::",
            stringify!(c_nc)
        )
    );
}
#[test]
fn bindgen_test_layout_DDCA_Any_Vcp_Value() {
    const UNINIT: ::std::mem::MaybeUninit<DDCA_Any_Vcp_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DDCA_Any_Vcp_Value>(),
        24usize,
        concat!("Size of: ", stringify!(DDCA_Any_Vcp_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<DDCA_Any_Vcp_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(DDCA_Any_Vcp_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DDCA_Any_Vcp_Value),
            "::",
            stringify!(val)
        )
    );
}
extern "C" {
    #[doc = " Returns the ddcutil version as a struct of 3 8 bit integers.\n\n @return version numbers"]
    pub fn ddca_ddcutil_version() -> DDCA_Ddcutil_Version_Spec;
}
extern "C" {
    #[doc = " Returns the ddcutil version as a string in the form \"major.minor.micro\".\n\n @return version string (caller must not free)"]
    pub fn ddca_ddcutil_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the full ddcutil version as a string, possibly with a suffix,\n\n @return string in form \"1.3.0\" or \"1.3.0-dev\" (caller must not free)\n\n @since 1.2.0"]
    pub fn ddca_ddcutil_extended_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Queries the options with which the **ddcutil** library was built.\n\n @return  flags byte\n\n | Defined Bits: | |\n |:-------| :--------------\n |#DDCA_BUILT_WITH_USB  | built with USB support\n |#DDCA_BUILT_WITH_FAILSIM | built with failure simulation\n"]
    pub fn ddca_build_options() -> DDCA_Build_Option_Flags;
}
extern "C" {
    #[doc = " Gets a copy of the detailed error information for the previous\n  API call, if the call supports detailed error information (only a\n  few do).\n\n  @return  copy of detailed error information (user must free)\n\n  @since 0.9.0"]
    pub fn ddca_get_error_detail() -> *mut DDCA_Error_Detail;
}
extern "C" {
    #[doc = " Frees a detailed error information record\n\n  @param[in]  ddca_erec  error information to free\n\n  @since 0.9.0"]
    pub fn ddca_free_error_detail(ddca_erec: *mut DDCA_Error_Detail);
}
extern "C" {
    #[doc = " Issues a detailed report of a #DDCA_Error_Detail instance.\n\n  @param[in] ddca_erec  error information record\n  @param[in] depth      logical indentation depth"]
    pub fn ddca_report_error_detail(
        ddca_erec: *mut DDCA_Error_Detail,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns the symbolic name for a ddcutil status code\n\n @param[in] status_code numeric status code\n @return    symbolic name, e.g. EBUSY, DDCRC_INVALID_DATA\n @retval    NULL if unrecognized code\n\n @remark\n The returned value is a pointer into internal persistent\n data structures and should not be freed by the caller."]
    pub fn ddca_rc_name(status_code: DDCA_Status) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a description of a ddcutil status code\n\n @param[in] status_code numeric status code\n @return    explanation of status code, e.g. \"device or resource busy\"\n @retval    \"unknown status code\" if unrecognized code\n\n @remark\n The returned value is a pointer into internal persistent\n data structures and should not be free'd by the caller."]
    pub fn ddca_rc_desc(status_code: DDCA_Status) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "I2C is an inherently unreliable protocol.  The application is responsible for\nretry management.\nThe maximum number of retries can be tuned.\nThere are 3 retry contexts:\n- An I2C write followed by a read.  Most DDC operations are of this form.\n- An I2C write without a subsequent read.  DDC operations to set a VCP feature\nvalue are in this category.\n- Some DDC operations, such as reading the capabilities string, reading table\nfeature and writing table features require multiple write/read exchanges.\nThese multi-part exchanges have a separate retry count for the entire operation.\n/\n///@{\n/** Gets the upper limit on a max tries value that can be set.\n\n @return maximum max tries value allowed on set_max_tries()"]
    pub fn ddca_max_max_tries() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the maximum number of I2C tries for the specified operation type.\n @param[in]  retry_type   I2C operation type\n @return maximum number of tries\n\n @remark\n This setting is global, not thread-specific."]
    pub fn ddca_get_max_tries(retry_type: DDCA_Retry_Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the maximum number of I2C retries for the specified operation type\n @param[in] retry_type    I2C operation type\n @param[in] max_tries     maximum count to set\n @retval    DDCRC_ARG     max_tries < 1 or > #ddca_get_max_tries()\n\n @remark\n This setting is global, not thread-specific."]
    pub fn ddca_set_max_tries(
        retry_type: DDCA_Retry_Type,
        max_tries: ::std::os::raw::c_int,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Controls whether VCP values are read after being set.\n\n @param[in] onoff true/false\n @return  prior value\n\n @remark This setting is thread-specific."]
    pub fn ddca_enable_verify(onoff: bool) -> bool;
}
extern "C" {
    #[doc = " Query whether VCP values are read after being set.\n @retval true values are verified after being set\n @retval false values are not verified\n\n @remark This setting is thread-specific."]
    pub fn ddca_is_verify_enabled() -> bool;
}
extern "C" {
    #[doc = " Controls the force I2C slave address setting.\n\n  Normally, ioctl operation I2C_SLAVE is used to set the I2C slave address.\n  If that returns EBUSY and this setting is in effect, slave address setting\n  is retried using operation I2C_SLAVE_FORCE.\n\n  @param[in] onoff true/false\n  @return  prior value\n  @since 1.2.2"]
    pub fn ddca_enable_force_slave_address(onoff: bool) -> bool;
}
extern "C" {
    #[doc = " Query the force I2C slave address setting.\n\n  @return true/false\n  @since 1.2.2"]
    pub fn ddca_is_force_slave_address_enabled() -> bool;
}
extern "C" {
    #[doc = " Sets the sleep multiplier factor to be used for new threads.\n\n  @param[in]  multiplier, must be >= 0 and <= 10\n  @return     old multiplier, -1.0f if invalid multiplier specified\n\n  @remark\n  This function is intended for use only during program initialization,\n  typically from a value passed on the command line.\n  Consequently there are no associated lock/unlock functions for the value."]
    pub fn ddca_set_default_sleep_multiplier(multiplier: f64) -> f64;
}
extern "C" {
    #[doc = " Gets the sleep multiplier factor used for new threads\n\n @return multiplier"]
    pub fn ddca_get_default_sleep_multiplier() -> f64;
}
extern "C" {
    #[doc = " @deprecated use #ddca_set_default_sleep_multiplier()"]
    pub fn ddca_set_global_sleep_multiplier(multiplier: f64);
}
extern "C" {
    #[doc = " @deprecated use #ddca_get_default_sleep_multiplier()"]
    pub fn ddca_get_global_sleep_multiplier() -> f64;
}
extern "C" {
    #[doc = " Sets the sleep multiplier factor for the current thread.\n\n  @param[in]  multiplier, must be >= 0 and <= 10\n  @return     old multiplier, -1.0f if invalid multiplier specified"]
    pub fn ddca_set_sleep_multiplier(multiplier: f64) -> f64;
}
extern "C" {
    #[doc = " Gets the sleep multiplier for the current thread\n\n  @return[in] sleep multiplier"]
    pub fn ddca_get_sleep_multiplier() -> f64;
}
extern "C" {
    #[doc = " Redirects output on the current thread that normally would go to **stdout**"]
    pub fn ddca_set_fout(fout: *mut FILE);
}
extern "C" {
    #[doc = " Redirects output on the current thread that normally goes to **stdout** back to **stdout**"]
    pub fn ddca_set_fout_to_default();
}
extern "C" {
    #[doc = " Redirects output on the current thread that normally would go to **stderr**"]
    pub fn ddca_set_ferr(ferr: *mut FILE);
}
extern "C" {
    #[doc = " Redirects output on the current thread that normally goes to **stderr** back to **stderr**"]
    pub fn ddca_set_ferr_to_default();
}
extern "C" {
    #[doc = " Begins capture of **stdout** and optionally **stderr** output on the\n  current thread to a thread-specific in-memory buffer.\n\n  @note  If output is already being captured, this function has no effect.\n  @since 0.9.0"]
    pub fn ddca_start_capture(flags: DDCA_Capture_Option_Flags);
}
extern "C" {
    #[doc = " Ends capture of **stdout** output and returns the contents of the\n  in-memory buffer.\n\n  Upon termination, normal thread output is directed to **stdout**.\n  If error output was also being captured, error output is redirected\n  to **stderr**.\n\n  @return captured output as a string, caller responsible for freeing\n\n  @note\n  If output is not currently being captured, returns a 0 length string.\n\n  @note  Writes messages to actual **stderr** in case of error.\n  @since 0.9.0"]
    pub fn ddca_end_capture() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the current output level for the current thread\n  @return      output level"]
    pub fn ddca_get_output_level() -> DDCA_Output_Level;
}
extern "C" {
    #[doc = " Sets the output level for the current thread\n  @param[in]      new output level\n  @return         prior output level"]
    pub fn ddca_set_output_level(newval: DDCA_Output_Level) -> DDCA_Output_Level;
}
extern "C" {
    #[doc = " Gets the name of an output level\n  @param[in]  val  output level id\n  @return     output level name (do not free)"]
    pub fn ddca_output_level_name(val: DDCA_Output_Level) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Controls whether messages describing DDC protocol errors are output\n  @param[in] onoff    if true, errors will be issued\n  @return    prior value\n\n  This setting is global to all threads."]
    pub fn ddca_enable_report_ddc_errors(onoff: bool) -> bool;
}
extern "C" {
    #[doc = " Indicates whether messages describing DDC protocol errors are output.\n\n  This setting is global to all threads."]
    pub fn ddca_is_report_ddc_errors_enabled() -> bool;
}
extern "C" {
    #[doc = " Turn on tracing for a specific function.\n\n  @param[in]  funcname   function name\n\n  @remark\n  The function must include trace calls."]
    pub fn ddca_add_traced_function(funcname: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Turn on all tracing in a specific source file.\n\n  @param[in] filename  simple file name, with or without the \".c\" extension,\n                        e.g. vcp_feature_set.c, vcp_feature_set"]
    pub fn ddca_add_traced_file(filename: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Replaces the groups being traced\n\n  @param[in] trace_flags  bitfield indicating groups to trace"]
    pub fn ddca_set_trace_groups(trace_flags: DDCA_Trace_Group);
}
extern "C" {
    #[doc = " Adds to the groups being traced\n\n  @param[in] trace_flags  bitfield indicating groups to trace\n\n  @since 1.2.0"]
    pub fn ddca_add_trace_groups(trace_flags: DDCA_Trace_Group);
}
extern "C" {
    #[doc = " Given a trace group name, returns its identifier.\n  Case is ignored.\n\n  @param[in] name trace group name\n  @return    trace group identifier\n  @retval    TRC_NEVER unrecognized name"]
    pub fn ddca_trace_group_name_to_value(name: *mut ::std::os::raw::c_char) -> DDCA_Trace_Group;
}
extern "C" {
    #[doc = " Sets tracing options\n\n  @param[in] options  enum that can be used as bit flags"]
    pub fn ddca_set_trace_options(options: DDCA_Trace_Options);
}
extern "C" {
    pub fn ddca_enable_sleep_suppression(newval: bool) -> bool;
}
extern "C" {
    pub fn ddca_is_sleep_suppression_enabled() -> bool;
}
extern "C" {
    #[doc = " Resets all **ddcutil** statistics"]
    pub fn ddca_reset_stats();
}
extern "C" {
    #[doc = " Assigns a description to the the current thread.\n\n  @param[in] description"]
    pub fn ddca_set_thread_description(description: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Appends text to the current thread description.\n\n  @param[in] description]"]
    pub fn ddca_append_thread_description(description: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ddca_get_thread_descripton() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Show execution statistics.\n\n  @param[in] stats  bitflags of statistics types to show\n  @param[in] include_per_thread_data include per thread detail\n  @param[in] depth  logical indentation depth"]
    pub fn ddca_show_stats(
        stats: DDCA_Stats_Type,
        include_per_thread_data: bool,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Enable display of internal exception reports (Error_Info).\n\n  @param[in] enable  true/false\n  @return prior value"]
    pub fn ddca_enable_error_info(enable: bool) -> bool;
}
extern "C" {
    #[doc = " Controls whether USB devices are checked during display detection\n\n  Must be called before any API call that triggers display detection.\n\n  @param[in] onoff\n  @retval    DDCRC_OK                success\n  @retval    DDCRC_INVALID_OPERATION display detection has already occurred\n  @retval    DDCRC_UNIMPLEMENTED     ddcutil not built with USB monitor support\n\n  @remark\n  The default is to check USB devices.\n\n  This setting is global to all threads."]
    pub fn ddca_enable_usb_display_detection(onoff: bool) -> DDCA_Status;
}
extern "C" {
    #[doc = " Reports whether USB devices are checked as part of display detection\n\n  @retval true  USB devices are checked\n  @retval false USB devices are not checked"]
    pub fn ddca_ddca_is_usb_display_detection_enabled() -> bool;
}
extern "C" {
    #[doc = " Gets display references list for all detected displays.\n\n  @param[in]  include_invalid_displays if true, displays that do not support DDC are included\n  @param[out] drefs_loc where to return pointer to null-terminated array of #DDCA_Display_Ref\n  @retval     0  always succeeds\n\n  @since 1.2.0"]
    pub fn ddca_get_display_refs(
        include_invalid_displays: bool,
        drefs_loc: *mut *mut DDCA_Display_Ref,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets publicly visible information about a display reference\n\n  The returned struct can simply be free()'d by the client.\n\n  @param  ddca_dref display reference\n  @param  dinfo_loc where to return pointer to newly allocated #DDCA_Display_Info\n  @param  DDCRC_OK  no error\n  @retval DDCRC_ARG invalid display reference\n\n  @since 1.2.0"]
    pub fn ddca_get_display_info(
        ddca_dref: DDCA_Display_Ref,
        dinfo_loc: *mut *mut DDCA_Display_Info,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Frees a #DDCA_Display_Info struct.\n\n  This is a convenience function. #DDCA_Display_Info is copied to\n  the client and contains no pointers.  It can simply be free()'d\n  by the client.\n\n  @param info_rec pointer to instance to free\n\n  @since 1.2.0"]
    pub fn ddca_free_display_info(info_rec: *mut DDCA_Display_Info);
}
extern "C" {
    #[doc = " Gets a list of the detected displays.\n\n  @param[in]  include_invalid_displays if true, displays that do not support DDC are included\n  @param[out] dlist_loc where to return pointer to #DDCA_Display_Info_List\n  @retval     0  always succeeds"]
    pub fn ddca_get_display_info_list2(
        include_invalid_displays: bool,
        dlist_loc: *mut *mut DDCA_Display_Info_List,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Frees a list of detected displays.\n\n  This is a convenience function. #DDCA_Display_Info_List\n  contains no pointers and is copied to the client, so the\n  list can simply be free'd by the client.\n\n  @param[in] dlist pointer to #DDCA_Display_Info_List"]
    pub fn ddca_free_display_info_list(dlist: *mut DDCA_Display_Info_List);
}
extern "C" {
    #[doc = " Presents a report on a single display.\n  The report is written to the current FOUT device for the current thread.\n\n  @param[in]  dinfo  pointer to a DDCA_Display_Info struct\n  @param[in]  depth  logical indentation depth\n\n  @remark\n  For a report intended for users, apply #ddca_report_display_by_dref()\n  to **dinfo->dref**."]
    pub fn ddca_report_display_info(dinfo: *mut DDCA_Display_Info, depth: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Reports on all displays in a list of displays.\n  The report is written to the current FOUT device for the current thread.\n\n  @param[in]  dlist  pointer to a DDCA_Display_Info_List\n  @param[in]  depth  logical indentation depth"]
    pub fn ddca_report_display_info_list(
        dlist: *mut DDCA_Display_Info_List,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Reports on all active displays.\n  This function hooks into the code used by command \"ddcutil detect\"\n\n  @param[in] include_invalid_displays if true, report displays that don't support DDC\n  @param[in] depth  logical indentation depth\n  @return    number of MCCS capable displays"]
    pub fn ddca_report_displays(
        include_invalid_displays: bool,
        depth: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reinitializes detected displays\n\n  - closes all open displays, releasing any display locks\n  - n. all existing display handles become invalid (TODO: validate dh similarly to dref)\n  - releases display refs (all existing display refs become invalid)\n  - releases i2c bus info\n  - rescans i2c buses\n  - redetects displays\n\n  @since 1.2.0"]
    pub fn ddca_redetect_displays() -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using the display number assigned by ddcutil\n @param[in]  dispno  display number\n @param[out] did_loc    where to return display identifier handle\n @retval     0\n @ingroup api_display_spec"]
    pub fn ddca_create_dispno_display_identifier(
        dispno: ::std::os::raw::c_int,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using an I2C bus number\n @param[in]  busno  I2C bus number\n @param[out] did_loc   where to return display identifier handle\n @retval     0\n\n @ingroup api_display_spec"]
    pub fn ddca_create_busno_display_identifier(
        busno: ::std::os::raw::c_int,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using some combination of the manufacturer id,\n model name string and serial number string.  At least 1 of the 3 must be specified.\n @param[in]  mfg_id    3 letter manufacturer id\n @param[in]  model     model name string\n @param[in]  sn        serial number string\n @param[out] did_loc   where to return display identifier handle\n @retval     0         success\n @retval     DDCRC_ARG all arguments NULL, or at least 1 too long\n\n @ingroup api_display_spec"]
    pub fn ddca_create_mfg_model_sn_display_identifier(
        mfg_id: *const ::std::os::raw::c_char,
        model: *const ::std::os::raw::c_char,
        sn: *const ::std::os::raw::c_char,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using a 128 byte EDID\n @param[in]   edid       pointer to 128 byte EDID\n @param[out]  did_loc    where to return display identifier handle\n @retval      0          success\n @retval      DDCRC_ARG  edid==NULL\n\n @ingroup api_display_spec"]
    pub fn ddca_create_edid_display_identifier(
        edid: *const u8,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using a USB bus number and device number\n @param[in]  bus    USB bus number\n @param[in]  device USB device number\n @param[out] did_loc   where to return display identifier handle\n @retval 0 success\n\n  @ingroup api_display_spec"]
    pub fn ddca_create_usb_display_identifier(
        bus: ::std::os::raw::c_int,
        device: ::std::os::raw::c_int,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Creates a display identifier using a /dev/usb/hiddev device number\n @param[in] hiddev_devno hiddev device number\n @param[out] did_loc   where to return display identifier handle\n @retval 0  success\n\n  @ingroup api_display_spec"]
    pub fn ddca_create_usb_hiddev_display_identifier(
        hiddev_devno: ::std::os::raw::c_int,
        did_loc: *mut DDCA_Display_Identifier,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Release the memory of a display identifier\n @param[in] did  display identifier, may be NULL\n @retval 0          success\n @retval DDCRC_ARG  invalid display identifier\n\n @remark\n Does nothing and returns 0 if **did** is NULL."]
    pub fn ddca_free_display_identifier(did: DDCA_Display_Identifier) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a string representation of a display identifier.\n\n  The string is valid until the display identifier is freed.\n\n  @param[in]  did    display identifier\n  @return     string representation of display identifier, NULL if invalid\n\n  @ingroup api_display_spec"]
    pub fn ddca_did_repr(did: DDCA_Display_Identifier) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "  @deprecated use #ddca_get_display_ref()\n  Gets a display reference for a display identifier.\n  Normally, this is a permanently allocated #DDCA_Display_Ref\n  created by monitor detection and does not need to be freed.\n  Use #ddca_free_display_ref() to safely free.\n @param[in]  did      display identifier\n @param[out] dref_loc where to return display reference\n @retval     0                     success\n @retval     DDCRC_ARG             did is not a valid display identifier handle\n @retval     DDCRC_INVALID_DISPLAY display not found\n\n @ingroup api_display_spec"]
    pub fn ddca_create_display_ref(
        did: DDCA_Display_Identifier,
        dref_loc: *mut DDCA_Display_Ref,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets a display reference for a display identifier.\n  This is a permanently allocated #DDCA_Display_Ref\n  created by monitor detection and does not need to be freed.\n @param[in]  did      display identifier\n @param[out] dref_loc where to return display reference\n @retval     0                     success\n @retval     DDCRC_ARG             did is not a valid display identifier handle\n @retval     DDCRC_INVALID_DISPLAY display not found\n\n @since 0.9.5\n @ingroup api_display_spec"]
    pub fn ddca_get_display_ref(
        did: DDCA_Display_Identifier,
        dref_loc: *mut DDCA_Display_Ref,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = "  @deprecated All display references are persistent\n\n Frees a display reference.\n\n Use this function to safely release a #DDCA_Display_Ref.\n If the display reference was dynamically created, it is freed.\n If the display reference was permanently allocated (normal case), does nothing.\n @param[in] dref  display reference to free\n @retval DDCRC_OK     success, or dref == NULL\n @retval DDCRC_ARG    dref does not point to a valid display reference\n @retval DDCRC_LOCKED dref is to a transient instance, and it is referenced\n                      by an open display handle\n\n @ingroup api_display_spec"]
    pub fn ddca_free_display_ref(dref: DDCA_Display_Ref) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a string representation of a display reference\n\n  The returned value is valid until the next call to this function on\n  the current thread.\n\n  @param[in]   dref display reference\n  @return      string representation of display reference, NULL if invalid"]
    pub fn ddca_dref_repr(dref: DDCA_Display_Ref) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Writes a report on the specified display reference to the current FOUT device\n @param[in] dref   display reference\n @param[in] depth  logical indentation depth\n\n @ingroup api_display_spec"]
    pub fn ddca_dbgrpt_display_ref(dref: DDCA_Display_Ref, depth: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Open a display\n @param[in]  ddca_dref    display reference for display to open\n @param[in]  wait         if true, wait if display locked by another thread\n @param[out] ddca_dh_loc  where to return display handle\n @return     status code\n\n Fails if display is already opened by another thread.\n @ingroup api_display_spec"]
    pub fn ddca_open_display2(
        ddca_dref: DDCA_Display_Ref,
        wait: bool,
        ddca_dh_loc: *mut DDCA_Display_Handle,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Close an open display\n @param[in]  ddca_dh   display handle, if NULL do nothing\n @retval     DDCRC_OK  close succeeded, or ddca_dh == NULL\n @retval     DDCRC_ARG invalid handle\n @return     -errno    from underlying OS close()\n\n @ingroup api_display_spec"]
    pub fn ddca_close_display(ddca_dh: DDCA_Display_Handle) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a string representation of a display handle.\n  The string is valid until until the handle is closed.\n\n @param[in] ddca_dh  display handle\n @return string  representation of display handle, NULL if\n                 argument is NULL or not a display handle\n\n  @ingroup api_display_spec"]
    pub fn ddca_dh_repr(ddca_dh: DDCA_Display_Handle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the display reference for display handle.\n\n  @param[in] ddca_dh   display handle\n  @return #DDCA_Display_Ref of the handle,\n          NULL if invalid display handle\n\n  @since 0.9.0"]
    pub fn ddca_display_ref_from_handle(ddca_dh: DDCA_Display_Handle) -> DDCA_Display_Ref;
}
extern "C" {
    #[doc = " Retrieves the capabilities string for a monitor.\n\n  @param[in]  ddca_dh     display handle\n  @param[out] caps_loc    address at which to return pointer to capabilities string.\n  @return     status code\n\n  It is the responsibility of the caller to free the returned string."]
    pub fn ddca_get_capabilities_string(
        ddca_dh: DDCA_Display_Handle,
        caps_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Parse the capabilities string.\n\n  @param[in] capabilities_string      unparsed capabilities string\n  @param[out] parsed_capabilities_loc address at which to return pointer to newly allocated\n                                      #DDCA_Capabilities struct\n  @return     status code\n\n  It is the responsibility of the caller to free the returned struct\n  using ddca_free_parsed_capabilities().\n\n  This function currently parses the VCP feature codes and MCCS version.\n  It could be extended to parse additional information such as cmds if necessary."]
    pub fn ddca_parse_capabilities_string(
        capabilities_string: *mut ::std::os::raw::c_char,
        parsed_capabilities_loc: *mut *mut DDCA_Capabilities,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Frees a DDCA_Capabilities struct\n\n  @param[in] parsed_capabilities  pointer to struct to free,\n                                  does nothing if NULL."]
    pub fn ddca_free_parsed_capabilities(parsed_capabilities: *mut DDCA_Capabilities);
}
extern "C" {
    #[doc = " Reports the contents of a DDCA_Capabilities struct.\n\n  The report is written to the current FOUT location.\n\n  If the current output level is #DDCA_OL_VERBOSE, additional\n  information is written, including command codes.\n\n  @param[in]  parsed_capabilities  pointer to #DDCA_Capabilities struct\n  @param[in]  ddca_dref            display reference, may be NULL\n  @param[in]  depth  logical       indentation depth\n\n  @remark\n  If ddca_dref is not NULL, feature value names will reflect any loaded monitor definition files\n  @since 0.9.3"]
    pub fn ddca_report_parsed_capabilities_by_dref(
        parsed_capabilities: *mut DDCA_Capabilities,
        ddca_dref: DDCA_Display_Ref,
        depth: ::std::os::raw::c_int,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Reports the contents of a DDCA_Capabilities struct.\n\n  The report is written to the current FOUT location.\n\n  If the current output level is #DDCA_OL_VERBOSE, additional\n  information is written, including command codes.\n\n  @param[in]  parsed_capabilities  pointer to #DDCA_Capabilities struct\n  @param[in]  ddca_dh              display handle, may be NULL\n  @param[in]  depth                logical indentation depth\n  @retval     0                    success\n  @retval     DDCRC_ARG            invalid display handle\n\n  @remark\n  If ddca_dh is not NULL, feature value names will reflect any loaded monitor definition files\n  @since 0.9.3"]
    pub fn ddca_report_parsed_capabilities_by_dh(
        p_caps: *mut DDCA_Capabilities,
        ddca_dh: DDCA_Display_Handle,
        depth: ::std::os::raw::c_int,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Reports the contents of a DDCA_Capabilities struct.\n\n  The report is written to the current FOUT location.\n\n  If the current output level is #DDCA_OL_VERBOSE, additional\n  information is written, including command codes.\n\n  @param[in]  parsed_capabilities  pointer to #DDCA_Capabilities struct\n  @param[in]  ddca_dref            display reference\n  @param[in]  depth  logical       indentation depth\n\n  @remark\n  Any user supplied feature definitions for the monitor are ignored."]
    pub fn ddca_report_parsed_capabilities(
        parsed_capabilities: *mut DDCA_Capabilities,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Returns the VCP feature codes defined in a\n  parsed capabilities record as a #DDCA_Feature_LIst\n\n  @param[in] parsed_caps  parsed capabilities\n  @return bitfield of feature ids\n  @since 0.9.0"]
    pub fn ddca_feature_list_from_capabilities(
        parsed_caps: *mut DDCA_Capabilities,
    ) -> DDCA_Feature_List;
}
extern "C" {
    #[doc = " Gets the MCCS version of a monitor.\n\n  @param[in]    ddca_dh   display handle\n  @param[out]   p_vspec   where to return version spec\n  @return       DDCRC_ARG invalid display handle\n\n  @remark Returns version 0.0 (#DDCA_VSPEC_UNKNOWN) if feature DF cannot be read"]
    pub fn ddca_get_mccs_version_by_dh(
        ddca_dh: DDCA_Display_Handle,
        p_vspec: *mut DDCA_MCCS_Version_Spec,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Controls whether user defined features (aka dynamic features) are supported.\n\n  @param[in] onoff true/false\n  @return    prior value\n\n  @since 0.9.3"]
    pub fn ddca_enable_udf(onoff: bool) -> bool;
}
extern "C" {
    #[doc = " Query whether user defined features (aka dynamic features) are supported.\n\n  @retval true  UDF enabled\n  @retval false UDF disabled\n\n  @since 0.9.3"]
    pub fn ddca_is_udf_enabled() -> bool;
}
extern "C" {
    #[doc = " Loads any user supplied feature definition files for the specified\n display.  Does nothing if they have already been loaded.\n\n @param[in] ddca_dref display reference\n\n @remark\n User supplied feature definition files are not yet publicly supported.\n\n @since 0.9.3"]
    pub fn ddca_dfr_check_by_dref(ddca_dref: DDCA_Display_Ref) -> DDCA_Status;
}
extern "C" {
    #[doc = " Loads any user supplied feature definition files for the specified\n display.  Does nothing if they have already been loaded.\n\n @param[in] ddca_dh display handle\n\n @remark\n User supplied feature definition files are not yet publicly supported.\n @since 0.9.3"]
    pub fn ddca_dfr_check_by_dh(ddca_dh: DDCA_Display_Handle) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets metadata for a VCP feature.\n\n @param[in]  vspec            VCP version\n @param[in]  feature_code     VCP feature code\n @param[in]  create_default_if_not_found\n @param[out] meta_loc         return pointer to metadata here\n @return     status code\n @retval     DDCRC_ARG        invalid display handle\n @retval     DDCRC_UNKNOWN_FEATURE unrecognized feature code and\n                              !create_default_if_not_found\n\n  It is the responsibility of the caller to free the returned DDCA_Feature_Metadata instance.\n\n @remark\n Note that VCP characteristics (C vs NC, RW vs RO, etc) can vary by MCCS version.\n @remark\n Only takes into account VCP version.  Useful for reporting display agnostic\n feature information.  For display sensitive feature information, i.e. taking\n into account the specific monitor model, use #ddca_get_feature_metdata_by_dref()\n or #ddca_get_feature_metadata_by_dh().\n\n @since 0.9.3"]
    pub fn ddca_get_feature_metadata_by_vspec(
        feature_code: DDCA_Vcp_Feature_Code,
        vspec: DDCA_MCCS_Version_Spec,
        create_default_if_not_found: bool,
        meta_loc: *mut *mut DDCA_Feature_Metadata,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets metadata for a VCP feature.\n\n Note that VCP characteristics (C vs NC, RW vs RO, etc) can vary by MCCS version.\n\n @param[in]  ddca_dref        display reference\n @param[in]  feature_code     VCP feature code\n @param[in]  create_default_if_not_found\n @param[out] meta_loc         return pointer to metadata here\n @return     status code\n @retval     DDCRC_ARG        invalid display reference\n @retval     DDCRC_UNKNOWN_FEATURE unrecognized feature code and\n                              !create_default_if_not_found\n\n It is the responsibility of the caller to free the returned DDCA_Feature_Metadata instance.\n\n @remark\n This function first checks if there is a user supplied feature definition\n for the monitor.  If not, it looks up feature metadata based on the\n VCP version of the monitor.\n @remark\n Note that feature characteristics (C vs NC, RW vs RO, etc) can vary by MCCS version.\n @since 0.9.3"]
    pub fn ddca_get_feature_metadata_by_dref(
        feature_code: DDCA_Vcp_Feature_Code,
        ddca_dref: DDCA_Display_Ref,
        create_default_if_not_found: bool,
        meta_loc: *mut *mut DDCA_Feature_Metadata,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets metadata for a VCP feature.\n\n @param[in]  ddca_dh          display handle\n @param[in]  feature_code     VCP feature code\n @param[in]  create_default_if_not_found\n @param[out] meta_loc         return pointer to metadata here\n @return     status code\n @retval     DDCRC_ARG        invalid display handle\n @retval     DDCRC_UNKNOWN_FEATURE unrecognized feature code and\n                              !create_default_if_not_found\n\n It is the responsibility of the caller to free the returned DDCA_Feature_Metadata instance.\n\n @remark\n This function first checks if there is a user supplied feature definition\n for the monitor.  If not, it looks up feature metadata based on the\n VCP version of the monitor.\n @remark\n Note that feature characteristics (C vs NC, RW vs RO, etc) can vary by MCCS version.\n @since 0.9.3"]
    pub fn ddca_get_feature_metadata_by_dh(
        feature_code: DDCA_Vcp_Feature_Code,
        ddca_dh: DDCA_Display_Handle,
        create_default_if_not_found: bool,
        meta_loc: *mut *mut DDCA_Feature_Metadata,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = "  Frees a #DDCA_Feature_Metadata instance.\n\n  @param[in] metadata pointer to instance\n  @retval   0  normal\n  @since 0.9.3\n\n  @remark\n  It is not an error if the ***metadata*** pointer argument is NULL"]
    pub fn ddca_free_feature_metadata(metadata: *mut DDCA_Feature_Metadata);
}
extern "C" {
    #[doc = " Gets the VCP feature name.  If different MCCS versions use different names\n  for the feature, this function makes a best guess.\n\n @param[in]  feature_code feature code\n @return     pointer to feature name (do not free), NULL if unknown feature code\n\n @remark\n Since no specific display is indicated, this function ignores user defined\n monitor feature information."]
    pub fn ddca_get_feature_name(
        feature_code: DDCA_Vcp_Feature_Code,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the VCP feature name, which may vary by MCCS version and monitor model.\n\n @param[in]  feature_code  feature code\n @param[in]  dref          display reference\n @param[out] name_loc      where to return pointer to feature name (do not free)\n @return     status code\n\n @since 0.9.2"]
    pub fn ddca_get_feature_name_by_dref(
        feature_code: DDCA_Vcp_Feature_Code,
        dref: DDCA_Display_Ref,
        name_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Convenience function that searches a Feature Value Table for a\n  value and returns the corresponding name.\n  @param[in]   feature_value_table  pointer to first entry of table\n  @param[in]   feature_value        value to search for\n  @param[out]  value_name_loc       where to return pointer to name\n  @retval      DDCRC_OK  value found\n  @retval      DDCRC_NOT_FOUND  value not found\n\n @remark\n The value returned in **value_name_loc** is a pointer into the table\n data structure.  Do not free."]
    pub fn ddca_get_simple_nc_feature_value_name_by_table(
        feature_value_table: *mut DDCA_Feature_Value_Entry,
        feature_value: u8,
        value_name_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Outputs a debugging report of the @DDCA_Feature_Metadata data structure.\n\n  @param[in] md    pointer to @DDCA_Feature_Metadata instance\n  @param[in] depth logical indentation depth"]
    pub fn ddca_dbgrpt_feature_metadata(
        md: *mut DDCA_Feature_Metadata,
        depth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Shows information about a display, specified by a #Display_Ref\n\n Output is written using report functions\n\n @param[in] dref       pointer to display reference\n @param[in] depth      logical indentation depth\n @retval DDCRC_ARG invalid display ref\n @retval 0         success\n\n @remark\n The detail level shown is controlled by the output level setting\n for the current thread.\n\n @since 0.9.0"]
    pub fn ddca_report_display_by_dref(
        dref: DDCA_Display_Ref,
        depth: ::std::os::raw::c_int,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Empty feature list\n  @since 0.9.0"]
    pub static DDCA_EMPTY_FEATURE_LIST: DDCA_Feature_List;
}
extern "C" {
    #[doc = " Returns feature list symbolic name (for debug messages)\n\n  @param[in] feature_set_id\n  @return symbolic name (do not free)"]
    pub fn ddca_feature_list_id_name(
        feature_set_id: DDCA_Feature_Subset_Id,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Given a feature set id, returns a #DDCA_Feature_List specifying all the\n  feature codes in the set.\n\n  @param[in]  feature_set_id\n  @param[in]  dref                   display reference\n  @param[in]  include_table_features if true, Table type features are included\n  @param[out] points to feature list to be filled in\n  @retval     DDCRC_ARG  invalid display reference\n  @retval     DDCRC_OK   success\n\n  @since 0.9.0"]
    pub fn ddca_get_feature_list_by_dref(
        feature_set_id: DDCA_Feature_Subset_Id,
        dref: DDCA_Display_Ref,
        include_table_features: bool,
        feature_list_loc: *mut DDCA_Feature_List,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Empties a #DDCA_Feature_List\n\n  @param[in]  vcplist pointer to feature list\n\n  @remark\n  Alternatively, just set vcplist = DDCA_EMPTY_FEATURE_LIST\n  @since 0.9.0"]
    pub fn ddca_feature_list_clear(vcplist: *mut DDCA_Feature_List);
}
extern "C" {
    #[doc = " Adds a feature code to a #DDCA_Feature_List\n\n  @param[in]  vcplist   pointer to feature list\n  @param[in]  vcp_code  VCP feature code\n  @return     modified feature list\n\n  @remark\n  The feature list is modified in place and also returned.\n\n  @since 0.9.0"]
    pub fn ddca_feature_list_add(
        vcplist: *mut DDCA_Feature_List,
        vcp_code: u8,
    ) -> DDCA_Feature_List;
}
extern "C" {
    #[doc = " Tests if a #DDCA_Feature_List contains a VCP feature code\n\n  @param[in]  vcplist   feature list\n  @param[in]  vcp_code  VCP feature code\n  @return     true/false\n\n  @since 0.9.0"]
    pub fn ddca_feature_list_contains(vcplist: DDCA_Feature_List, vcp_code: u8) -> bool;
}
extern "C" {
    #[doc = " Tests if 2 feature lists are equal.\n\n  @param[in] vcplist1   first feature list\n  @param[in] vcplist2   second feature list\n  @return true if they contain the same features, false if not\n\n  @remark\n  The input feature lists are not modified.\n  @since 0.9.9"]
    pub fn ddca_feature_list_eq(vcplist1: DDCA_Feature_List, vcplist2: DDCA_Feature_List) -> bool;
}
extern "C" {
    #[doc = " Creates a union of 2 feature lists.\n\n  @param[in] vcplist1   first feature list\n  @param[in] vcplist2   second feature list\n  @return feature list in which a feature is set if it is in either\n          of the 2 input feature lists\n\n  @remark\n  The input feature lists are not modified.\n  @since 0.9.0"]
    pub fn ddca_feature_list_or(
        vcplist1: DDCA_Feature_List,
        vcplist2: DDCA_Feature_List,
    ) -> DDCA_Feature_List;
}
extern "C" {
    #[doc = " Creates the intersection of 2 feature lists.\n\n  @param[in] vcplist1   first feature list\n  @param[in] vcplist2   second feature list\n  @return feature list in which a feature is set if it is in both\n          of the 2 input feature lists\n\n  @remark\n  The input feature lists are not modified.\n  @since 0.9.0"]
    pub fn ddca_feature_list_and(
        vcplist1: DDCA_Feature_List,
        vcplist2: DDCA_Feature_List,
    ) -> DDCA_Feature_List;
}
extern "C" {
    #[doc = " Returns a feature list consisting of all the features in the\n  first list that are not in the second.\n\n  @param[in] vcplist1   first feature list\n  @param[in] vcplist2   second feature list\n  @return feature list in which a feature is set if it is in **vcplist1** but\n          not **vcplist2**\n\n  @remark\n  The input feature lists are not modified.\n  @since 0.9.0"]
    pub fn ddca_feature_list_and_not(
        vcplist1: DDCA_Feature_List,
        vcplist2: DDCA_Feature_List,
    ) -> DDCA_Feature_List;
}
extern "C" {
    #[doc = " Returns the number of features in a feature list\n\n  @param[in] feature_list   feature list\n  @return  number of features, 0 if feature_list == NULL\n\n  @since 0.9.0"]
    pub fn ddca_feature_list_count(feature_list: DDCA_Feature_List) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a string representation of a feature list as a\n  sequence of 2 character hex values.\n\n  @param[in] feature_list   feature list\n  @param[in] value_prefix   precede each value with this string, e.g. \"0x\"\n                            if NULL, then no preceding string\n  @param[in] sepstr         separator string between pair of values, e.g. \", \"\n                            if NULL, then no separator string\n  @return    string representation; The value is valid until the next call\n             to this function in the current thread.  Caller should not free.\n\n  @since 0.9.0"]
    pub fn ddca_feature_list_string(
        feature_list: DDCA_Feature_List,
        value_prefix: *const ::std::os::raw::c_char,
        sepstr: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a #DDCA_Table_Vcp_Value instance.\n\n  @param[in] table_value\n\n  @remark\n  Was previously named **ddca_free_table_value_response().\n  @since 0.9.0"]
    pub fn ddca_free_table_vcp_value(table_value: *mut DDCA_Table_Vcp_Value);
}
extern "C" {
    #[doc = " Frees a #DDCA_Any_Vcp_Value instance.\n\n  @param[in] valrec  pointer to #DDCA_Any_Vcp_Value instance\n  @since 0.9.0"]
    pub fn ddca_free_any_vcp_value(valrec: *mut DDCA_Any_Vcp_Value);
}
extern "C" {
    #[doc = " Produces a debugging report of a #DDCA_Any_Vcp_Value instance.\n  The report is written to the current FOUT device.\n  @param[in]  valrec  instance to report\n  @param[in]  depth   logical indentation depth\n  @since 0.9.0"]
    pub fn dbgrpt_any_vcp_value(valrec: *mut DDCA_Any_Vcp_Value, depth: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gets the value of a non-table VCP feature.\n\n @param[in]  ddca_dh       display handle\n @param[in]  feature_code  VCP feature code\n @param[out] valrec        pointer to response buffer provided by the caller,\n                           which will be filled in\n @return status code\n\n @remark\n If the returned status code is other than **DDCRC_OK**, a detailed\n error report can be obtained using #ddca_get_error_detail()\n @remark\n Renamed from **ddca_get_nontable_vcp_value()**\n @since 0.9.0"]
    pub fn ddca_get_non_table_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        valrec: *mut DDCA_Non_Table_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets the value of a table VCP feature.\n\n @param[in]  ddca_dh         display handle\n @param[in]  feature_code    VCP feature code\n @param[out] table_value_loc address at which to return the value\n @return status code\n\n @remark\n If the returned status code is other than **DDCRC_OK**, a detailed\n error report can be obtained using #ddca_get_error_detail()\n @note\n Implemented, but untested"]
    pub fn ddca_get_table_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        table_value_loc: *mut *mut DDCA_Table_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets the value of a VCP feature of any type.\n\n @param[in]  ddca_dh       display handle\n @param[in]  feature_code  VCP feature code\n @param[in]  value_type    value type\n @param[out] valrec_loc    address at which to return a pointer to a newly\n                           allocated #DDCA_Any_Vcp_Value\n @return status code\n\n @remark\n If the returned status code is other than **DDCRC_OK**, a detailed\n error report can be obtained using #ddca_get_error_detail()\n @remark\n Replaces **ddca_get_any_vcp_value()\n\n @since 0.9.0"]
    pub fn ddca_get_any_vcp_value_using_explicit_type(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        value_type: DDCA_Vcp_Value_Type,
        valrec_loc: *mut *mut DDCA_Any_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Gets the value of a VCP feature of any type.\n  The type is determined by using ddcutil's internal\n  feature description table.\n\n  Note that this function cannot be used for manufacturer-specific\n  feature codes (i.e. those in the range xE0..xFF), since ddcutil\n  does not know their type information.  Nor can it be used for\n  unrecognized feature codes.\n\n @param[in]  ddca_dh       display handle\n @param[in]  feature_code  VCP feature code\n @param[out] valrec_loc    address at which to return a pointer to a newly\n                           allocated #DDCA_Any_Vcp_Value\n @return status code\n\n @remark\n It an error to call this function for a manufacturer-specific feature or\n an unrecognized feature.\n @remark\n If the returned status code is other than **DDCRC_OK**, a detailed\n error report can be obtained using #ddca_get_error_detail()"]
    pub fn ddca_get_any_vcp_value_using_implicit_type(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        valrec_loc: *mut *mut DDCA_Any_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a string containing a formatted representation of the VCP value\n  of a feature.  It is the responsibility of the caller to free this value.\n\n  @param[in]  ddca_dh             Display handle\n  @param[in]  feature_code        VCP feature code\n  @param[out] formatted_value_loc Address at which to return the formatted value\n  @return     status code, 0 if success\n  @since 0.9.0\n  @deprecated Does not support user-supplied feature definitions"]
    pub fn ddca_get_formatted_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        formatted_value_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a formatted representation of a table VCP value.\n  It is the responsibility of the caller to free the returned string.\n\n  @param[in]  feature_code        VCP feature code\n  @param[in]  dref                display reference\n  @param[in]  table_value         table VCP value\n  @param[out] formatted_value_loc address at which to return the formatted value.\n  @return                         status code, 0 if success\n  @since 0.9.0"]
    pub fn ddca_format_table_vcp_value_by_dref(
        feature_code: DDCA_Vcp_Feature_Code,
        ddca_dref: DDCA_Display_Ref,
        table_value: *mut DDCA_Table_Vcp_Value,
        formatted_value_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a formatted representation of a non-table VCP value.\n  It is the responsibility of the caller to free the returned string.\n\n  @param[in]  feature_code        VCP feature code\n  @param[in]  dref                display reference\n  @param[in]  valrec              non-table VCP value\n  @param[out] formatted_value_loc address at which to return the formatted value.\n  @return                         status code, 0 if success\n  @since 0.9.0"]
    pub fn ddca_format_non_table_vcp_value_by_dref(
        feature_code: DDCA_Vcp_Feature_Code,
        dref: DDCA_Display_Ref,
        valrec: *mut DDCA_Non_Table_Vcp_Value,
        formatted_value_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a formatted representation of a VCP value of any type\n  It is the responsibility of the caller to free the returned string.\n\n  @param[in]  feature_code        VCP feature code\n  @param[in]  dref                display reference\n  @param[in]  valrec              non-table VCP value\n  @param[out] formatted_value_loc address at which to return the formatted value.\n  @return                         status code, 0 if success\n  @since 0.9.0"]
    pub fn ddca_format_any_vcp_value_by_dref(
        feature_code: DDCA_Vcp_Feature_Code,
        dref: DDCA_Display_Ref,
        valrec: *mut DDCA_Any_Vcp_Value,
        formatted_value_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Sets a non-table VCP value by specifying it's high and low bytes individually.\n\n  @param[in]   ddca_dh             display handle\n  @param[in]   feature_code        feature code\n  @param[in]   hi_byte             high byte of new value\n  @param[in]   lo_byte             low byte of new value\n  @return      status code"]
    pub fn ddca_set_non_table_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        hi_byte: u8,
        lo_byte: u8,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Sets a Table VCP value.\n\n  @param[in]   ddca_dh             display handle\n  @param[in]   feature_code        feature code\n  @param[in]   new_value           value to set\n  @return      status code\n  @since 0.9.0"]
    pub fn ddca_set_table_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        new_value: *mut DDCA_Table_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Sets a VCP value of any type.\n\n  @param[in]   ddca_dh        display handle\n  @param[in]   feature_code   feature code\n  @param[in]   new_value      value to set\n  @return      status code\n  @since 0.9.0"]
    pub fn ddca_set_any_vcp_value(
        ddca_dh: DDCA_Display_Handle,
        feature_code: DDCA_Vcp_Feature_Code,
        new_value: *mut DDCA_Any_Vcp_Value,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Returns a string containing monitor identification and values\n  for all detected features that should be saved when a monitor is\n  calibrated and restored when the calibration is applied.\n\n  @param[in]  ddca_dh                   display handle\n  @param[out] profile_values_string_loc address at which to return string\n  @return     status code"]
    pub fn ddca_get_profile_related_values(
        ddca_dh: DDCA_Display_Handle,
        profile_values_string_loc: *mut *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
extern "C" {
    #[doc = " Sets multiple feature values for a specified monitor.\n  The monitor identification and feature values are\n  encoded in the string.\n\n  @param[in] ddca_dh display handle\n  @param[in] profile_values_string string containing values\n  @return     status code\n\n  @remark\n  If **ddca_dh** is NULL, this function opens the first display\n  that matches the display identifiers in the **profile_values_string**.\n  If **ddca_dh** is non-NULL, then the identifiers in **profile_values_string**\n  must be consistent with the open display.\n  @remark\n  The non-NULL case exists to handle the unusual situation where multiple\n  displays have the same manufacturer, model, and serial number,\n  perhaps because the EDID has been cloned.\n  @remark\n  If the returned status code is **DDCRC_BAD_DATA** (others?), a detailed\n  error report can be obtained using #ddca_get_error_detail()"]
    pub fn ddca_set_profile_related_values(
        ddca_dh: DDCA_Display_Handle,
        profile_values_string: *mut ::std::os::raw::c_char,
    ) -> DDCA_Status;
}
